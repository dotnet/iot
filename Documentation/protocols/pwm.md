# PWM (Pulse Width Modulation)

PWM (Pulse Width Modulation) is a technique for controlling analog devices with digital outputs by varying the width of pulses in a fixed-frequency signal. PWM is commonly used to control LED brightness, motor speed, and servo position.

## What is PWM?

PWM generates a square wave with:
- **Fixed frequency** - How many pulses per second (Hz)
- **Variable duty cycle** - Percentage of time the signal is HIGH (0-100%)

A 50% duty cycle means the signal is HIGH half the time and LOW half the time, delivering effectively 50% power.

**Key concepts:**
- **Frequency** - Measured in Hz, determines how fast the signal oscillates
- **Duty Cycle** - Percentage (0-100%) or decimal (0.0-1.0) of time signal is HIGH
- **Period** - Time for one complete cycle (1/frequency)

**Common PWM applications:**
- **LED dimming** - Control brightness (50% duty cycle = half brightness)
- **Motor speed control** - Vary effective voltage to motors
- **Servo control** - Position servos with specific pulse widths
- **Audio generation** - Create simple tones
- **Power regulation** - Efficient power delivery

For detailed information about PWM vs other protocols, see [Understanding Protocols](../fundamentals/understanding-protocols.md).

## Hardware PWM vs Software PWM

**Hardware PWM:**
- Generated by dedicated hardware timers
- Precise, consistent timing
- Doesn't consume CPU
- Limited number of pins (2 channels on Raspberry Pi)
- **Recommended** for motor control, servos

**Software PWM:**
- Generated by CPU with timers
- Less precise, timing can jitter
- Consumes CPU resources
- Available on any GPIO pin
- Suitable for simple LED dimming

This guide focuses on **hardware PWM**.

## Example

```csharp
using System;
using System.Device.Pwm;
using System.Threading;

// Create PWM channel
// Chip 0, Channel 0, 1000 Hz, 50% duty cycle
using PwmChannel pwm = PwmChannel.Create(0, 0, 1000, 0.5);

// Start PWM
pwm.Start();

Console.WriteLine("PWM running at 50% duty cycle");
Thread.Sleep(2000);

// Change duty cycle (LED brightness)
pwm.DutyCycle = 0.1;  // 10% - dim
Thread.Sleep(2000);

pwm.DutyCycle = 0.9;  // 90% - bright
Thread.Sleep(2000);

// Stop PWM
pwm.Stop();
```

**Parameters:**
- `0` - PWM chip number (0 is default on Raspberry Pi)
- `0` - PWM channel (0 or 1 for PWM0 or PWM1)
- `1000` - Frequency in Hz
- `0.5` - Duty cycle (50%)

**Typical frequencies:**
- LED dimming: 100-1000 Hz
- Motor control: 1000-20,000 Hz
- Servo control: 50 Hz (20 ms period)
- Audio tones: Frequency of desired pitch

## Enabling Hardware PWM on Raspberry Pi

### Configure Device Tree Overlay

Edit the config file:

```bash
sudo nano /boot/firmware/config.txt
```

> [!Note]
> Prior to *Bookworm*, Raspberry Pi OS stored the boot partition at `/boot/`. Since Bookworm, the boot partition is located at `/boot/firmware/`. Adjust the path to `sudo nano /boot/config.txt` if you have an older OS version.

### Single Channel PWM

Add one of these overlays:

| PWM Channel | GPIO Pin | Physical Pin | Overlay |
|-------------|----------|--------------|---------|
| PWM0 | GPIO 12 | 32 | `dtoverlay=pwm,pin=12,func=4` |
| PWM0 | GPIO 18 | 12 | `dtoverlay=pwm,pin=18,func=2` |
| PWM1 | GPIO 13 | 33 | `dtoverlay=pwm,pin=13,func=4` |
| PWM1 | GPIO 19 | 35 | `dtoverlay=pwm,pin=19,func=2` |

Example for PWM0 on GPIO 18:

```text
dtoverlay=pwm,pin=18,func=2
```

Save (`Ctrl+X`, then `Y`, then `Enter`) and reboot:

```bash
sudo reboot
```

### Dual Channel PWM

For two independent PWM outputs:

| PWM0 GPIO | PWM1 GPIO | Overlay |
|-----------|-----------|---------|
| GPIO 12 (pin 32) | GPIO 13 (pin 33) | `dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4` |
| GPIO 18 (pin 12) | GPIO 13 (pin 33) | `dtoverlay=pwm-2chan,pin=18,func=2,pin2=13,func2=4` |
| GPIO 12 (pin 32) | GPIO 19 (pin 35) | `dtoverlay=pwm-2chan,pin=12,func=4,pin2=19,func2=2` |
| GPIO 18 (pin 12) | GPIO 19 (pin 35) | `dtoverlay=pwm-2chan,pin=18,func=2,pin2=19,func2=2` |

Example for PWM0 on GPIO 18 and PWM1 on GPIO 19:

```text
dtoverlay=pwm-2chan,pin=18,func=2,pin2=19,func2=2
```

### Verify PWM is Enabled

Check for PWM chip:

```bash
ls /sys/class/pwm/
```

Should show `pwmchip0`.

Check PWM channels:

```bash
ls /sys/class/pwm/pwmchip0/
```

### Permissions

Add your user to the `gpio` group:

```bash
sudo usermod -aG gpio $USER
```

Log out and log back in for changes to take effect.

## Advanced Usage

### Fading LED

```csharp
using System.Device.Pwm;
using System.Threading;

using PwmChannel pwm = PwmChannel.Create(0, 0, 1000, 0.0);
pwm.Start();

// Fade in
for (double duty = 0.0; duty <= 1.0; duty += 0.01)
{
    pwm.DutyCycle = duty;
    Thread.Sleep(20);
}

// Fade out
for (double duty = 1.0; duty >= 0.0; duty -= 0.01)
{
    pwm.DutyCycle = duty;
    Thread.Sleep(20);
}

pwm.Stop();
```

### Servo Control

Servos typically use 50 Hz (20 ms period) with pulse widths:
- 1 ms (5% duty) = 0°
- 1.5 ms (7.5% duty) = 90°
- 2 ms (10% duty) = 180°

```csharp
using System.Device.Pwm;
using System.Threading;

using PwmChannel servo = PwmChannel.Create(0, 0, 50, 0.075);  // 50 Hz, 7.5% = center
servo.Start();

// Move to 0°
servo.DutyCycle = 0.05;  // 1 ms pulse
Thread.Sleep(1000);

// Move to 90°
servo.DutyCycle = 0.075;  // 1.5 ms pulse
Thread.Sleep(1000);

// Move to 180°
servo.DutyCycle = 0.10;  // 2 ms pulse
Thread.Sleep(1000);

servo.Stop();
```

### Motor Speed Control

```csharp
using System.Device.Pwm;
using System.Device.Gpio;

// Assuming motor controller with PWM speed input and direction pin
using PwmChannel speedPwm = PwmChannel.Create(0, 0, 10000, 0.0);  // 10 kHz
using GpioController gpio = new();

int directionPin = 17;
gpio.OpenPin(directionPin, PinMode.Output);

speedPwm.Start();

// Forward at 50% speed
gpio.Write(directionPin, PinValue.High);
speedPwm.DutyCycle = 0.5;
Thread.Sleep(2000);

// Forward at 100% speed
speedPwm.DutyCycle = 1.0;
Thread.Sleep(2000);

// Reverse at 50% speed
gpio.Write(directionPin, PinValue.Low);
speedPwm.DutyCycle = 0.5;
Thread.Sleep(2000);

// Stop
speedPwm.DutyCycle = 0.0;
speedPwm.Stop();
```

## Troubleshooting

### "The chip number 0 is invalid or is not enabled"

```
System.ArgumentException: The chip number 0 is invalid or is not enabled.
```

**Cause:** Hardware PWM not enabled in config.txt.

**Solution:** Add PWM overlay to `/boot/firmware/config.txt` as described above and reboot.

### "Access to the path '/sys/class/pwm/pwmchip0/export' is denied"

```
System.UnauthorizedAccessException: Access to the path '/sys/class/pwm/pwmchip0/export' is denied.
```

**Cause:** User doesn't have permission to access PWM.

**Solution:**
```bash
sudo usermod -aG gpio $USER
# Log out and log back in
```

Alternatively, run with sudo (not recommended for production):
```bash
sudo dotnet run
```

### PWM Not Working on Expected Pin

**Verify configuration:**
1. Check `/boot/firmware/config.txt` has correct overlay
2. Verify GPIO pin matches overlay configuration
3. Use pinout diagram to confirm physical pin location
4. Reboot after config changes

**Check PWM export:**
```bash
# Check if channel is exported
ls /sys/class/pwm/pwmchip0/

# If not, export it (as root)
echo 0 > /sys/class/pwm/pwmchip0/export
```

### Frequency or Duty Cycle Not Accurate

**Hardware limitations:**
- PWM clock is shared between channels
- Changing frequency affects both PWM0 and PWM1
- Very high or very low frequencies may have limited precision

**Solutions:**
- Use frequencies within typical ranges (100-100,000 Hz)
- Test and verify with oscilloscope if precision is critical
- Consider software PWM for extreme frequencies (less precise)

### Flickering with LEDs

**Cause:** Frequency too low (< 100 Hz causes visible flickering).

**Solution:** Increase frequency to 1000 Hz or higher:
```csharp
PwmChannel pwm = PwmChannel.Create(0, 0, 1000, 0.5);  // 1 kHz
```

### Servo Not Moving to Correct Position

**Check:**
1. Frequency is 50 Hz
2. Duty cycle range is 5-10% (1-2 ms pulses)
3. Servo is powered separately (servos draw significant current)
4. Common ground between Raspberry Pi and servo power supply

**Calibration may vary:**
Some servos use slightly different pulse widths. Experiment with duty cycle values between 0.04-0.11.

## Best Practices

1. **Use hardware PWM** for time-critical applications (motors, servos)
2. **Set appropriate frequency** - Check device requirements
3. **Start with low duty cycle** - Gradually increase to avoid damage
4. **Separate power** - Use external power supply for motors/servos
5. **Common ground** - Always connect grounds
6. **Dispose properly** - Use `using` statements
7. **Stop PWM** when done - Call `pwm.Stop()`
8. **Consider heat** - High duty cycles on power devices generate heat

## Related Documentation

- [Understanding Protocols](../fundamentals/understanding-protocols.md) - When to use PWM vs other protocols
- [GPIO Basics](fundamentals/gpio-basics.md) - Understanding digital I/O
- [Troubleshooting Guide](../troubleshooting.md) - Common PWM issues
- [Device Bindings](../../src/devices/README.md) - Drivers for PWM-based devices

## External Resources

- [PWM Wikipedia](https://en.wikipedia.org/wiki/Pulse-width_modulation)
- [Raspberry Pi PWM Documentation](https://www.raspberrypi.org/documentation/hardware/raspberrypi/)
- [Servo Control Tutorial](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-8-using-a-servo-motor)
- [Motor Control with PWM](https://learn.sparkfun.com/tutorials/pulse-width-modulation)
